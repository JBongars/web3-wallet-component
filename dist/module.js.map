{"mappings":"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","sources":["src/index.ts","src/WalletStore.ts","src/algorand/index.ts","src/algorand/myalgo/index.ts","src/types.ts","src/algorand/Algorand.ts","src/ethereum/index.ts","src/ethereum/metamask/index.ts","src/containers/index.ts","src/containers/window.ts","src/ethereum/Ethereum.ts","src/utils.ts"],"sourcesContent":["export * from \"./WalletStore\";\nexport * from \"./types\";\nexport * from \"./ethereum\";\nexport * from \"./algorand\";\nexport * from \"./containers\";\n","import { MyAlgo, MyAlgoState } from \"./algorand\";\nimport { MetaMask, MetaMaskState } from \"./ethereum\";\nimport {\n  NotImplementedError,\n  useWallets,\n  WalletInterface,\n  WALLETS,\n} from \"./types\";\nimport { clone, iffyClone, useProxy } from \"./utils\";\n\ntype WalletID = keyof typeof WALLETS;\n\ntype WalletState = {\n  id: WalletID;\n  state: {\n    [key: string]: unknown;\n  };\n  previousStates: {\n    [key: string]: unknown;\n  }[];\n};\n\ntype WalletStoreConfig = {\n  previousWalletState?: WalletState[];\n};\n\nclass WalletStore implements useWallets {\n  private walletStates: WalletState[];\n\n  constructor(config: WalletStoreConfig) {\n    this.walletStates = config.previousWalletState || [];\n  }\n\n  private updateState(key: WalletID, newState: { [key: string]: unknown }) {\n    const wallet: WalletState | null | undefined = this.walletStates.find(\n      (elem) => elem.id === key\n    );\n\n    if (!wallet || wallet === null) {\n      const newWalletState = {\n        id: key,\n        state: newState,\n        previousStates: [],\n      };\n      this.walletStates.push(newWalletState);\n      return newWalletState;\n    }\n\n    wallet.previousStates.push(wallet.state);\n    wallet.state = newState;\n\n    return wallet;\n  }\n\n  public use(walletName: WalletID): any {\n    return useProxy((prop: string | Symbol) => {\n      if (prop === \"state\") {\n        return iffyClone(\n          this.walletStates.find((elem) => elem.id === walletName)?.state\n        );\n      }\n\n      // there may be an issue where if the client preserves multiple\n      // proxies, the wallet state could fall out of sync...\n      let target: WalletInterface<{ [key: string]: unknown }>;\n      const previousState: unknown = this.walletStates.find(\n        (elem) => elem.id === walletName\n      )?.state;\n\n      switch (walletName) {\n        case WALLETS.METAMASK:\n          target = new MetaMask(previousState as MetaMaskState);\n          break;\n        case WALLETS.MYALGO:\n          target = new MyAlgo(previousState as MyAlgoState);\n          break;\n        default:\n          throw new NotImplementedError();\n      }\n\n      if (\n        typeof target[\n        prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ] !== \"function\"\n      ) {\n        return target[\n          prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ];\n      }\n\n      return async (...args: any[]) => {\n        const result = await target[\n          prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ](...(args as []));\n\n        this.updateState(walletName, target.toJSON());\n\n        return result;\n      };\n    });\n  }\n\n  public toJSON() {\n    return this.walletStates.map((elem) => clone(elem)) as WalletState[];\n  }\n}\n\nexport { WalletStore };\nexport type { WalletID, WalletState, WalletStoreConfig };\n","export * from \"./myalgo\";\nexport * from \"./Algorand\";\n","import {\n  SignedTx,\n  AlgorandTxn,\n  EncodedTransaction,\n} from \"@randlabs/myalgo-connect\";\nimport {\n  Signer,\n  WALLET_STATUS,\n  WalletInterface,\n  NotImplementedError,\n} from \"./../../types\";\nimport { Asset, MyAlgoState } from \"./types\";\nimport MyAlgoConnect from \"@randlabs/myalgo-connect\";\n\nconst initialState: Readonly<MyAlgoState> = Object.freeze({\n  accounts: [],\n  isConnected: false,\n});\n\nclass MyAlgo implements WalletInterface<MyAlgoState> {\n  public state: MyAlgoState;\n  private provider: MyAlgoConnect | undefined;\n\n  constructor(state?: MyAlgoState) {\n    if (state) {\n      this.state = { ...state };\n    } else {\n      this.state = { ...initialState };\n    }\n  }\n\n  public async init(): Promise<WALLET_STATUS> {\n    console.log(\"about to init!\");\n    return WALLET_STATUS.OK;\n  }\n\n  public async signIn(): Promise<WALLET_STATUS> {\n    console.log(\"about to sign in!\");\n\n    const myAlgoConnect = this.getProvider();\n\n    this.state.accounts = await myAlgoConnect.connect();\n    this.state.isConnected = this.state.accounts.length > 0;\n\n    return WALLET_STATUS.OK;\n  }\n\n  public async signOut(): Promise<WALLET_STATUS> {\n    this.state.accounts = [];\n    this.state.isConnected = false;\n\n    return WALLET_STATUS.OK;\n  }\n\n  public async getBalance(): Promise<string> {\n    throw new NotImplementedError();\n  }\n\n  public async getAssets(): Promise<Asset[]> {\n    throw new NotImplementedError();\n  }\n\n  public toJSON(): MyAlgoState {\n    return this.state;\n  }\n\n  public async getSigner(): Promise<Signer> {\n    return async (\n      transactions: unknown[]\n    ): Promise<{ signedTransaction: SignedTx[]; status: WALLET_STATUS }> => {\n      const myAlgoConnect = this.getProvider();\n      const signedTx = await myAlgoConnect.signTransaction(\n        transactions as (AlgorandTxn | EncodedTransaction)[]\n      );\n\n      return {\n        signedTransaction: signedTx,\n        status: WALLET_STATUS.OK,\n      };\n    };\n  }\n\n  public getProvider(): MyAlgoConnect {\n    if (this.provider instanceof MyAlgoConnect) {\n      return this.provider;\n    }\n\n    this.provider = new MyAlgoConnect();\n    return this.provider;\n  }\n}\n\nexport { MyAlgo };\nexport type { MyAlgoState };\n","import { MyAlgo } from \"./algorand\";\nimport { MetaMask } from \"./ethereum\";\n\nenum WALLET_STATUS {\n  OK,\n  LOGIN_ERROR,\n  WALLET_ERROR,\n  EXTENSION_NOT_FOUND,\n  ACCOUNT_NOT_FOUND,\n}\n\nconst WALLETS = {\n  MYALGO: \"MYALGO\",\n  METAMASK: \"METAMASK\",\n} as const;\n\ninterface useWallets {\n  use(walletName: \"MYALGO\"): MyAlgo;\n  use(walletName: \"METAMASK\"): MetaMask;\n}\n\nclass NotImplementedError extends Error {}\nclass WalletNotInstalled extends Error {}\n\ntype Signer = (\n  transactions: unknown[]\n) => Promise<{ signedTransaction: unknown[]; status: WALLET_STATUS }>;\n\ninterface WalletInterface<T> {\n  init: () => Promise<WALLET_STATUS>;\n  signIn: () => Promise<WALLET_STATUS>;\n  signOut: () => Promise<WALLET_STATUS>;\n  getSigner: () => Promise<Signer>;\n  getBalance: () => Promise<string>;\n  getAssets: () => Promise<unknown[]>;\n  toJSON: () => T;\n}\n\nexport {\n  WALLETS,\n  NotImplementedError,\n  WalletInterface,\n  WALLET_STATUS,\n  WalletNotInstalled,\n};\nexport type { Signer, useWallets };\n","import { MyAlgo, MyAlgoState } from \"./myalgo\";\n\ntype AlgorandState = {\n  myAlgo?: MyAlgoState;\n};\n\nclass Algorand {\n  public myAlgo: MyAlgo;\n\n  constructor(data?: AlgorandState) {\n    this.myAlgo = new MyAlgo(data?.myAlgo);\n  }\n}\n\nexport { Algorand, AlgorandState };\n","export * from \"./metamask\";\nexport * from \"./Ethereum\";\n","import {\n  NotImplementedError,\n  Signer,\n  WALLET_STATUS,\n  WalletInterface,\n  WalletNotInstalled,\n} from \"../../types\";\nimport { Asset, MetaMaskState } from \"./types\";\nimport { ethers } from \"ethers\";\nimport {\n  TransactionRequest,\n  TransactionResponse,\n} from \"@ethersproject/abstract-provider\";\nimport { useWindow } from \"../../containers\";\n\nconst initialState: Readonly<MetaMaskState> = Object.freeze({\n  accounts: [],\n  isConnected: false,\n});\n\nclass MetaMask implements WalletInterface<MetaMaskState> {\n  public state: MetaMaskState;\n  public provider?: ethers.providers.Web3Provider;\n\n  constructor(state?: MetaMaskState) {\n    if (state) {\n      this.state = { ...state };\n    } else {\n      this.state = { ...initialState };\n    }\n  }\n\n  public async init(): Promise<WALLET_STATUS> {\n    this.provider = await this.getProvider();\n    await this.mountEventListeners();\n\n    return WALLET_STATUS.OK;\n  }\n\n  public async signIn(): Promise<WALLET_STATUS> {\n    const provider = await this.getProvider();\n    this.state.accounts = await provider.send(\"eth_requestAccounts\", []);\n    this.state.isConnected = this.state.accounts.length > 0;\n\n    return WALLET_STATUS.OK;\n  }\n\n  public async signOut(): Promise<WALLET_STATUS> {\n    this.state.accounts = [];\n    this.state.isConnected = false;\n\n    return WALLET_STATUS.OK;\n  }\n\n  public async getSigner(): Promise<Signer> {\n    return async (\n      transactions: unknown[]\n    ): Promise<{\n      signedTransaction: TransactionResponse[];\n      status: WALLET_STATUS;\n    }> => {\n      const provider = this.provider || (await this.getProvider());\n      const transactionResponse = await provider\n        .getSigner()\n        .sendTransaction(transactions as TransactionRequest);\n\n      return {\n        signedTransaction: [transactionResponse],\n        status: WALLET_STATUS.OK,\n      };\n    };\n  }\n\n  public async getBalance(): Promise<string> {\n    if (!this.state.isConnected) {\n      return WALLET_STATUS.ACCOUNT_NOT_FOUND as unknown as string;\n    }\n\n    const provider = this.provider || (await this.getProvider());\n\n    const balance = await provider.getBalance(this.state.accounts[0]);\n\n    return balance.toString();\n  }\n\n  public async getAssets(): Promise<Asset[]> {\n    throw new NotImplementedError();\n  }\n\n  public toJSON(): MetaMaskState {\n    return this.state;\n  }\n\n  public async mountEventListeners(\n    callback?: (accounts: string[]) => Promise<unknown>\n  ) {\n    const provider = this.provider || (await this.getProvider());\n\n    provider.on(\"accountsChanged\", async (accounts: string[]) => {\n      this.state.accounts = accounts;\n\n      if (callback) {\n        return callback(accounts);\n      }\n    });\n  }\n\n  public async unmountEventListeners(callback?: () => Promise<unknown>) {\n    const provider = this.provider || (await this.getProvider());\n\n    provider.removeListener(\"accountsChanged\", async () => {\n      if (callback) {\n        return callback();\n      }\n    });\n  }\n\n  public async getProvider(): Promise<ethers.providers.Web3Provider> {\n    const ethereum = (await useWindow(async (w) => (w as any).ethereum)) as any;\n\n    if (!ethereum) {\n      throw new WalletNotInstalled();\n    }\n\n    return new ethers.providers.Web3Provider(ethereum);\n  }\n}\n\nexport { MetaMask };\nexport type { MetaMaskState };\n","export * from \"./window\";\n","const useWindow = async (cb: (windows: Window) => Promise<unknown>) => {\n  try {\n    // @ts-expect-error\n    if (process.browser) {\n      return await cb(window);\n    }\n  } catch (err) {\n    console.log(\"Error opening window...\");\n    console.log(err);\n  }\n\n  return null;\n};\n\nexport { useWindow };\n","import { MetaMask, MetaMaskState } from \"./metamask\";\n\ntype EthereumState = {\n  metaMask?: MetaMaskState;\n};\n\nclass Ethereum {\n  public metaMask: MetaMask;\n\n  constructor(data?: EthereumState) {\n    this.metaMask = new MetaMask(data?.metaMask);\n  }\n}\n\nexport { Ethereum, EthereumState };\n","const clone = (obj: { [key: string]: unknown }): { [key: string]: unknown } =>\n  JSON.parse(JSON.stringify(obj));\n\nconst iffyClone = (\n  obj: { [key: string]: unknown } | null | undefined\n): { [key: string]: unknown } | null | undefined =>\n  obj && obj !== null ? clone(obj) : null;\n\nconst useProxy = (\n  callback: (prop: string | Symbol) => Promise<unknown> | unknown\n): any =>\n  new Proxy(\n    {},\n    {\n      get(_target, prop, receiver) {\n        const result = callback(prop);\n        if (result === null) return receiver;\n        else return result;\n      },\n    }\n  );\n\nexport { clone, iffyClone, useProxy };\n"],"names":[],"version":3,"file":"module.js.map"}