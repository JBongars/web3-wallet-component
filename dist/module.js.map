{"mappings":"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","sources":["src/index.ts","src/WalletStore.ts","src/algorand/index.ts","src/algorand/myalgo/index.ts","src/types.ts","src/algorand/Algorand.ts","src/ethereum/index.ts","src/ethereum/metamask/index.ts","src/ethereum/Ethereum.ts","src/utils.ts","src/containers/index.ts","src/containers/window.ts"],"sourcesContent":["export * from \"./WalletStore\";\nexport * from \"./types\";\nexport * from \"./ethereum\";\nexport * from \"./algorand\";\nexport * from \"./containers\";\n","import { MyAlgo, MyAlgoState } from \"./algorand\";\nimport { MetaMask, MetaMaskState } from \"./ethereum\";\nimport {\n  NotImplementedError,\n  useWallets,\n  WalletInterface,\n  WALLETS,\n} from \"./types\";\nimport { clone, iffyClone, useProxy } from \"./utils\";\n\ntype WalletID = keyof typeof WALLETS;\n\ntype WalletState = {\n  id: WalletID;\n  state: {\n    [key: string]: unknown;\n  };\n  previousStates: {\n    [key: string]: unknown;\n  }[];\n};\n\ntype WalletStoreConfig = {\n  previousWalletState?: WalletState[];\n};\n\nclass WalletStore implements useWallets {\n  private walletStates: WalletState[];\n\n  constructor(config: WalletStoreConfig) {\n    this.walletStates = config.previousWalletState || [];\n  }\n\n  private updateState(key: WalletID, newState: { [key: string]: unknown }) {\n    const wallet: WalletState | null | undefined = this.walletStates.find(\n      (elem) => elem.id === key\n    );\n\n    if (!wallet || wallet === null) {\n      const newWalletState = {\n        id: key,\n        state: newState,\n        previousStates: [],\n      };\n      this.walletStates.push(newWalletState);\n      return newWalletState;\n    }\n\n    wallet.previousStates.push(wallet.state);\n    wallet.state = newState;\n\n    return wallet;\n  }\n\n  public use(walletName: WalletID): any {\n    return useProxy((prop: string | Symbol) => {\n      if (prop === \"state\") {\n        return iffyClone(\n          this.walletStates.find((elem) => elem.id === walletName)?.state\n        );\n      }\n\n      // there may be an issue where if the client preserves multiple\n      // proxies, the wallet state could fall out of sync...\n      let target: WalletInterface<{ [key: string]: unknown }>;\n      const previousState: unknown = this.walletStates.find(\n        (elem) => elem.id === walletName\n      )?.state;\n\n      switch (walletName) {\n        case WALLETS.METAMASK:\n          target = new MetaMask(previousState as MetaMaskState);\n          break;\n        case WALLETS.MYALGO:\n          target = new MyAlgo(previousState as MyAlgoState);\n          break;\n        default:\n          throw new NotImplementedError();\n      }\n\n      if (\n        typeof target[\n          prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ] !== \"function\"\n      ) {\n        return target[\n          prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ];\n      }\n\n      return async (...args: any[]) => {\n        const result = await target[\n          prop as keyof WalletInterface<{ [key: string]: unknown }>\n        ](...(args as []));\n\n        this.updateState(walletName, target.toJSON());\n\n        return result;\n      };\n    });\n  }\n\n  public toJSON() {\n    return this.walletStates.map((elem) => clone(elem)) as WalletState[];\n  }\n}\n\nexport { WalletStore };\nexport type { WalletID, WalletState, WalletStoreConfig };\n","export * from \"./myalgo\";\nexport * from \"./Algorand\";\n","import {\n  NotImplementedError,\n  Signer,\n  WalletInterface,\n  WALLET_STATUS,\n} from \"~/src/types\";\nimport { Asset, State } from \"./types\";\n\ntype MyAlgoState = State;\n\nconst initialState: Readonly<State> = Object.freeze({\n  data1: \"\",\n  data2: \"\",\n  counter: 0,\n});\n\nclass MyAlgo implements WalletInterface<State> {\n  public state: State;\n\n  constructor(state?: State) {\n    if (state) {\n      this.state = { ...state };\n    } else {\n      this.state = { ...initialState };\n    }\n  }\n\n  public test(): string {\n    this.state.counter++;\n    return \"ok\";\n  }\n\n  public async init(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async signIn(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async signOut(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async getSigner(): Promise<Signer> {\n    throw new NotImplementedError();\n  }\n\n  public async getBallance(): Promise<number> {\n    throw new NotImplementedError();\n  }\n\n  public async getAssets(): Promise<Asset[]> {\n    throw new NotImplementedError();\n  }\n\n  public toJSON(): State {\n    return this.state;\n  }\n}\n\nexport { MyAlgo };\nexport type { MyAlgoState };\n","import { MyAlgo } from \"./algorand\";\nimport { MetaMask } from \"./ethereum\";\n\nenum WALLET_STATUS {\n  OK,\n  LOGIN_ERROR,\n  WALLET_ERROR,\n  EXTENSION_NOT_FOUND,\n}\n\nconst WALLETS = {\n  MYALGO: \"MYALGO\",\n  METAMASK: \"METAMASK\",\n} as const;\n\ninterface useWallets {\n  use(walletName: \"MYALGO\"): MyAlgo;\n  use(walletName: \"METAMASK\"): MetaMask;\n}\n\nclass NotImplementedError extends Error {}\n\ntype Signer = (\n  transactions: unknown[]\n) => Promise<{ signedTransaction: unknown[]; status: WALLET_STATUS }>;\n\ninterface WalletInterface<T> {\n  init: () => Promise<WALLET_STATUS>;\n  signIn: () => Promise<WALLET_STATUS>;\n  signOut: () => Promise<WALLET_STATUS>;\n  getSigner: () => Promise<Signer>;\n  getBallance: () => Promise<number>;\n  getAssets: () => Promise<unknown[]>;\n  toJSON: () => T;\n}\n\nexport { WALLETS, NotImplementedError, WalletInterface };\nexport type { WALLET_STATUS, Signer, useWallets };\n","import { MyAlgo, MyAlgoState } from \"./myalgo\";\n\ntype AlgorandState = {\n  myAlgo?: MyAlgoState;\n};\n\nclass Algorand {\n  public myAlgo: MyAlgo;\n\n  constructor(data?: AlgorandState) {\n    this.myAlgo = new MyAlgo(data?.myAlgo);\n  }\n}\n\nexport { Algorand, AlgorandState };\n","export * from \"./metamask\";\nexport * from \"./Ethereum\";\n","import {\n  NotImplementedError,\n  Signer,\n  WalletInterface,\n  WALLET_STATUS,\n} from \"~/src/types\";\nimport { Asset, State } from \"./types\";\n\ntype MetaMaskState = State;\n\nconst initialState: Readonly<State> = Object.freeze({\n  data1: \"\",\n  data2: \"\",\n});\n\nclass MetaMask implements WalletInterface<State> {\n  public state: State;\n\n  constructor(state?: State) {\n    if (state) {\n      this.state = { ...state };\n    } else {\n      this.state = { ...initialState };\n    }\n  }\n\n  public async init(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async signIn(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async signOut(): Promise<WALLET_STATUS> {\n    throw new NotImplementedError();\n  }\n\n  public async getSigner(): Promise<Signer> {\n    throw new NotImplementedError();\n  }\n\n  public async getBallance(): Promise<number> {\n    throw new NotImplementedError();\n  }\n\n  public async getAssets(): Promise<Asset[]> {\n    throw new NotImplementedError();\n  }\n\n  public toJSON(): State {\n    return this.state;\n  }\n}\n\nexport { MetaMask };\nexport type { MetaMaskState };\n","import { MetaMask, MetaMaskState } from \"./metamask\";\n\ntype EthereumState = {\n  metaMask?: MetaMaskState;\n};\n\nclass Ethereum {\n  public metaMask: MetaMask;\n\n  constructor(data?: EthereumState) {\n    this.metaMask = new MetaMask(data?.metaMask);\n  }\n}\n\nexport { Ethereum, EthereumState };\n","const clone = (obj: { [key: string]: unknown }): { [key: string]: unknown } =>\n  JSON.parse(JSON.stringify(obj));\n\nconst iffyClone = (\n  obj: { [key: string]: unknown } | null | undefined\n): { [key: string]: unknown } | null | undefined =>\n  obj && obj !== null ? clone(obj) : null;\n\nconst useProxy = (\n  callback: (prop: string | Symbol) => Promise<unknown> | unknown\n): any =>\n  new Proxy(\n    {},\n    {\n      get(_target, prop, receiver) {\n        const result = callback(prop);\n        if (result === null) return receiver;\n        else return result;\n      },\n    }\n  );\n\nexport { clone, iffyClone, useProxy };\n","export * from \"./window\";\n","const useWindow = async (cb: (windows: Window) => Promise<unknown>) => {\n  try {\n    // @ts-expect-error\n    if (process.browser) {\n      return await cb(window);\n    }\n  } catch (err) {\n    console.log(\"Error opening window...\");\n    console.log(err);\n  }\n\n  return null;\n};\n\nexport { useWindow };\n"],"names":[],"version":3,"file":"module.js.map","sourceRoot":"../"}